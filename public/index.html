<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yoga Studio with Avatar Pose Mapping</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body { margin: 0; display: flex; }
        canvas { display: block; }
        #pose-detection { width: 50%; position: relative; }
        #yoga-studio { width: 50%; }
        #status { position: absolute; top: 10px; left: 10px; font-size: 24px; font-weight: bold; }
    </style>
</head>
<body>
    <div id="pose-detection">
        <video id="video" width="720" height="700" autoplay style="display: none;"></video>
        <canvas id="output" width="720" height="700"></canvas>
        <div id="status"></div>
    </div>
    <div id="yoga-studio"></div>

    <script>
        let scene, camera, renderer, controls;
        let avatar, avatarSkeleton, avatarBones = {};
        let studioModel;

        // Add quaternion utilities
        const quatFromEuler = (x, y, z) => {
            const quat = new THREE.Quaternion();
            const euler = new THREE.Euler(x, y, z, 'XYZ');
            return quat.setFromEuler(euler);
        };

        async function setupCamera() {
            const video = document.getElementById('video');
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            return new Promise((resolve) => {
                video.onloadedmetadata = () => { resolve(video); };
            });
        }

        

        function init3DScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xcccccc);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / 2 / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1, 3);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth / 2, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('yoga-studio').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(-2, 4, 2);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1, 0);
            controls.update();

            loadStudioAndAvatar();
            
            window.addEventListener('resize', onWindowResize, false);
        }

        function loadStudioAndAvatar() {
            const loader = new THREE.GLTFLoader();
            
            // Load studio
            loader.load('studio_room.glb',
                (gltf) => {
                    studioModel = gltf.scene;
                    scene.add(studioModel);
                    studioModel.traverse((node) => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    loadAvatar();
                },
                undefined,
                (error) => console.error('Error loading studio:', error)
            );
        }

        function loadAvatar() {
            const loader = new THREE.GLTFLoader();
            loader.load('model.glb',
                (gltf) => {
                    avatar = gltf.scene;
                    avatar.position.set(0, 0, 0);
                    avatar.scale.set(1, 1, 1);
                    scene.add(avatar);

                    avatar.traverse((node) => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                        if (node.isBone) {
                            avatarBones[node.name] = node;
                        }
                        if (node.isSkinnedMesh) {
                            avatarSkeleton = node.skeleton;
                        }
                    });

                    // Store initial bone rotations
                    Object.values(avatarBones).forEach(bone => {
                        bone.initialRotation = bone.rotation.clone();
                    });
                },
                undefined,
                (error) => console.error('Error loading avatar:', error)
            );
        }

        function calculateJointRotation(keypoints, joint1, joint2, joint3) {
            const p1 = keypoints.find(kp => kp.part === joint1);
            const p2 = keypoints.find(kp => kp.part === joint2);
            const p3 = keypoints.find(kp => kp.part === joint3);

            if (p1 && p2 && p3 && p1.score > 0.5 && p2.score > 0.5 && p3.score > 0.5) {
                // Calculate vectors
                const v1 = new THREE.Vector3(
                    p2.position.x - p1.position.x,
                    p2.position.y - p1.position.y,
                    0
                );
                const v2 = new THREE.Vector3(
                    p3.position.x - p2.position.x,
                    p3.position.y - p2.position.y,
                    0
                );

                // Calculate angle
                return Math.atan2(v2.y, v2.x) - Math.atan2(v1.y, v1.x);
            }
            return null;
        }

        function updateAvatarPose(keypoints) {
            if (!avatar || !avatarSkeleton) return;

            // Update arm rotations
            const leftArmAngle = calculateJointRotation(keypoints, 'leftShoulder', 'leftElbow', 'leftWrist');
            const rightArmAngle = calculateJointRotation(keypoints, 'rightShoulder', 'rightElbow', 'rightWrist');
            
            if (leftArmAngle !== null && avatarBones['leftArm']) {
                const rotation = quatFromEuler(0, 0, leftArmAngle);
                avatarBones['leftArm'].quaternion.copy(rotation);
            }

            if (rightArmAngle !== null && avatarBones['rightArm']) {
                const rotation = quatFromEuler(0, 0, rightArmAngle);
                avatarBones['rightArm'].quaternion.copy(rotation);
            }

            // Update leg rotations
            const leftLegAngle = calculateJointRotation(keypoints, 'leftHip', 'leftKnee', 'leftAnkle');
            const rightLegAngle = calculateJointRotation(keypoints, 'rightHip', 'rightKnee', 'rightAnkle');

            if (leftLegAngle !== null && avatarBones['leftLeg']) {
                const rotation = quatFromEuler(0, 0, leftLegAngle);
                avatarBones['leftLeg'].quaternion.copy(rotation);
            }

            if (rightLegAngle !== null && avatarBones['rightLeg']) {
                const rotation = quatFromEuler(0, 0, rightLegAngle);
                avatarBones['rightLeg'].quaternion.copy(rotation);
            }

            // Update spine/torso rotation based on shoulders and hips
            const torsoKeypoints = keypoints.filter(kp => 
                ['leftShoulder', 'rightShoulder', 'leftHip', 'rightHip'].includes(kp.part)
            );

            if (torsoKeypoints.length === 4 && torsoKeypoints.every(kp => kp.score > 0.5)) {
                const shoulderCenter = {
                    x: (torsoKeypoints[0].position.x + torsoKeypoints[1].position.x) / 2,
                    y: (torsoKeypoints[0].position.y + torsoKeypoints[1].position.y) / 2
                };
                const hipCenter = {
                    x: (torsoKeypoints[2].position.x + torsoKeypoints[3].position.x) / 2,
                    y: (torsoKeypoints[2].position.y + torsoKeypoints[3].position.y) / 2
                };

                const torsoAngle = Math.atan2(
                    shoulderCenter.y - hipCenter.y,
                    shoulderCenter.x - hipCenter.x
                );

                if (avatarBones['spine']) {
                    const rotation = quatFromEuler(0, 0, torsoAngle);
                    avatarBones['spine'].quaternion.copy(rotation);
                }
            }

            if (avatarSkeleton) {
                avatarSkeleton.update();
            }
        }

        async function detectPose() {
            const net = await posenet.load();
            const video = await setupCamera();
            video.play();

            const canvas = document.getElementById('output');
            const ctx = canvas.getContext('2d');
            const status = document.getElementById('status');

            const rect = { x: 150, y: 100, width: 275, height: 575 };

            function drawRectangle() {
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = 4;
                // ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
                ctx.beginPath();
                ctx.moveTo(250,650);
                ctx.lineTo(500,650);
                ctx.lineTo(500,300);
                ctx.lineTo(700,300);
                ctx.lineTo(700,200);
                ctx.lineTo(500,200);
                ctx.lineTo(500,50);
                ctx.lineTo(250,50);
                ctx.lineTo(250,200);
                ctx.lineTo(50,200);
                ctx.lineTo(50,300);
                ctx.lineTo(250,300);
                ctx.lineTo(250,650);
                ctx.stroke();
            }

            function areKeypointsInsideRect(keypoints) {
                return keypoints.every((keypoint) => {
                    const { x, y } = keypoint.position;
                    if (200<=y<=300)
                {
                    return x>=50 && x<=700;
                }
                else
                {
                    return x>=250 && x<=500 && y>=650 && y<=50;
                }

                    // return x >= rect.x && x <= rect.x + rect.width &&
                    //        y >= rect.y && y <= rect.y + rect.height;
                });
            }

            async function poseDetectionFrame() {
                const pose = await net.estimateSinglePose(video, { flipHorizontal: false });

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                drawRectangle();

                const allKeypointsInside = areKeypointsInsideRect(pose.keypoints);
                status.textContent = allKeypointsInside ? 'Correct' : 'Incorrect';
                status.style.color = allKeypointsInside ? 'green' : 'red';

                updateAvatarPose(pose.keypoints);
                requestAnimationFrame(poseDetectionFrame);
            }

            poseDetectionFrame();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / 2 / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth / 2, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init3DScene();
        detectPose();
        animate();
    </script>
</body>
</html>
