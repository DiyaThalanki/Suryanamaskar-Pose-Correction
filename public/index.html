<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yoga Studio with Avatar Pose Mapping</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/posenet"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body { margin: 0; display: flex; }
        canvas { display: block; }
        #pose-detection { width: 50%; position: relative; }
        #yoga-studio { width: 50%; }
        #status { position: absolute; top: 10px; left: 10px; font-size: 24px; font-weight: bold; }
    </style>
</head>
<body>
    <div id="pose-detection">
        <video id="video" width="720" height="700" autoplay style="display: none;"></video>
        <canvas id="output" width="720" height="700"></canvas>
        <div id="status"></div>
    </div>
    <div id="yoga-studio"></div>

    <script>
        let scene, camera, renderer, controls;
        let avatar, avatarSkeleton, avatarBones = {};
        let studioModel;

        async function setupCamera() {
            const video = document.getElementById('video');
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            return new Promise((resolve) => {
                video.onloadedmetadata = () => { resolve(video); };
            });
        }

        function init3DScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xcccccc);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / 2 / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1, 3);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth / 2, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('yoga-studio').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(-2, 4, 2);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1, 0);
            controls.update();

            loadStudioAndAvatar();
            
            window.addEventListener('resize', onWindowResize, false);
        }

        function loadStudioAndAvatar() {
            const loader = new THREE.GLTFLoader();
            
            // Load studio
            loader.load('studio_room.glb',
                (gltf) => {
                    studioModel = gltf.scene;
                    scene.add(studioModel);
                    studioModel.traverse((node) => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                    });
                    loadAvatar();
                },
                undefined,
                (error) => console.error('Error loading studio:', error)
            );
        }

        function loadAvatar() {
            const loader = new THREE.GLTFLoader();
            loader.load('model.glb',
                (gltf) => {
                    avatar = gltf.scene;
                    avatar.position.set(0, 0, 0);
                    avatar.scale.set(1, 1, 1);
                    scene.add(avatar);

                    avatar.traverse((node) => {
                        if (node.isMesh) {
                            node.castShadow = true;
                            node.receiveShadow = true;
                        }
                        if (node.isBone) {
                            avatarBones[node.name] = node;
                        }
                        if (node.isSkinnedMesh) {
                            avatarSkeleton = node.skeleton;
                        }
                    });

                    // Store initial bone rotations
                    Object.values(avatarBones).forEach(bone => {
                        bone.initialRotation = bone.rotation.clone();
                    });
                },
                undefined,
                (error) => console.error('Error loading avatar:', error)
            );
        }

        function updateAvatarPose(keypoints) {
            keypoints.forEach((keypoint) => {
                let boneName;
                switch (keypoint.part) {
                    case 'nose':
                        boneName = 'Nose';
                        break;
                    case 'leftEye':
                        boneName = 'LeftEye';
                        break;
                    case 'rightEye':
                        boneName = 'RightEye';
                        break;
                    case 'leftEar':
                        boneName = 'LeftEar';
                        break;
                    case 'rightEar':
                        boneName = 'RightEar';
                        break;
                    case 'leftShoulder':
                        boneName = 'LeftShoulder';
                        break;
                    case 'rightShoulder':
                        boneName = 'RightShoulder';
                        break;
                    case 'leftElbow':
                        boneName = 'LeftElbow';
                        break;
                    case 'rightElbow':
                        boneName = 'RightElbow';
                        break;
                    case 'leftWrist':
                        boneName = 'LeftWrist';
                        break;
                    case 'rightWrist':
                        boneName = 'RightWrist';
                        break;
                    case 'leftHip':
                        boneName = 'LeftHip';
                        break;
                    case 'rightHip':
                        boneName = 'RightHip';
                        break;
                    case 'leftKnee':
                        boneName = 'LeftKnee';
                        break;
                    case 'rightKnee':
                        boneName = 'RightKnee';
                        break;
                    case 'leftAnkle':
                        boneName = 'LeftAnkle';
                        break;
                    case 'rightAnkle':
                        boneName = 'RightAnkle';
                        break;
                    default:
                        boneName = null;
                }

                const bone = avatar.getObjectByName(boneName);
                if (bone && keypoint.score > 0.5) {
                    let x = (keypoint.position.x / video.width) * 2 - 1;
                    let y = -(keypoint.position.y / video.height) * 2 + 1;
                    bone.position.set(x, y, 0);
                }
            });
        }

        async function detectPose() {
            const net = await posenet.load();
            const video = await setupCamera();
            video.play();

            const canvas = document.getElementById('output');
            const ctx = canvas.getContext('2d');

            async function poseDetectionFrame() {
                const pose = await net.estimateSinglePose(video, {
                    flipHorizontal: false,
                    decodingMethod: 'single-person'
                });

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                // Draw detected pose
                pose.keypoints.forEach(keypoint => {
                    if (keypoint.score > 0.5) {
                        ctx.beginPath();
                        ctx.arc(keypoint.position.x, keypoint.position.y, 5, 0, 2 * Math.PI);
                        ctx.fillStyle = 'red';
                        ctx.fill();
                    }
                });

                updateAvatarPose(pose.keypoints);
                requestAnimationFrame(poseDetectionFrame);
            }

            poseDetectionFrame();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / 2 / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth / 2, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init3DScene();
        detectPose();
        animate();
    </script>
</body>
</html>
